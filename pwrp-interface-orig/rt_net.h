/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _RT_NET_H_RPCGEN
#define _RT_NET_H_RPCGEN

#include <rpc/rpc.h>


#ifdef __cplusplus
extern "C" {
#endif

/* 
 * Proview   $Id: rt_net.x,v 1.13 2008-06-24 07:14:53 claes Exp $
 * Copyright (C) 2005 SSAB Oxelösund AB.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with the program, if not, write to the Free Software 
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef rt_net_h
#define rt_net_h

#if defined __cplusplus
extern "C" {
#endif

#ifndef pwr_h
#include "pwr.h"
#endif

#ifndef rt_qcom_h
#include "rt_qcom.h"
#endif

#ifndef co_xdr_h
# include "co_xdr.h"
#endif

#ifndef co_cdh_h
#include "co_cdh.h"
#endif

/** Protocol version. Increase whenever an
    incompatible change is done to the protocol.
    Update supported features in function id() in file rt_neth.c  */

#define net_cVersion 8

 /** @note DO NOT change this number */
#define net_cFirstCclassVersion 8 /* first version with cached classes */

#define net_cSendRcvTmo 20000 /* Timeout (ms) used in pams_rcv_msgw calls */
#define net_cProcHandler 110
#define net_cMsgClass 200

#define net_cSizeSmall 600
#define net_cSizeMedium 5000
#define net_cSizeLarge 9900



enum net_eMsg {
	net_eMsg__ = -1,
	net_eMsg_error = 0,
	net_eMsg_id = 0 + 1,
	net_eMsg_idAck = 0 + 2,
	net_eMsg_idAck2 = 0 + 3,
	net_eMsg_volumes = 0 + 4,
	net_eMsg_volumesR = 0 + 5,
	net_eMsg_subAdd = 0 + 6,
	net_eMsg_subRemove = 0 + 7,
	net_eMsg_subData = 0 + 8,
	net_eMsg_sanAdd = 0 + 9,
	net_eMsg_sanRemove = 0 + 10,
	net_eMsg_sanUpdate = 0 + 11,
	net_eMsg_nameToObject = 0 + 12,
	net_eMsg_oidToObject = 0 + 13,
	net_eMsg_objectR = 0 + 14,
	net_eMsg_getObjectInfo = 0 + 15,
	net_eMsg_getObjectInfoR = 0 + 16,
	net_eMsg_setObjectInfo = 0 + 17,
	net_eMsg_setObjectInfoR = 0 + 18,
	net_eMsg_flush = 0 + 19,
	net_eMsg_createObject = 0 + 20,
	net_eMsg_deleteObject = 0 + 21,
	net_eMsg_moveObject = 0 + 22,
	net_eMsg_renameObject = 0 + 23,
	net_eMsg_nodeUp = 0 + 24,
	net_eMsg_nodeDown = 0 + 25,
	net_eMsg_getCclass = 0 + 26,
	net_eMsg_getCclassR = 0 + 27,
	net_eMsg_getGclass = 0 + 28,
	net_eMsg_getGclassR = 0 + 29,
	net_eMsg_serverConnect = 0 + 30,
	net_eMsg_fileList = 0 + 31,
	net_eMsg_fileListR = 0 + 32,
	net_eMsg_getCircBuffer = 0 + 33,
	net_eMsg_getCircBufferR = 0 + 34,
	net_eMsg_updateCircBuffer = 0 + 35,
	net_eMsg_updateCircBufferR = 0 + 36,
	net_eMsg_ = 0 + 37,
	net_eMsg_volumes7 = 0 + 38,
	net_eMsg_end = 0 + 39,
};
typedef enum net_eMsg net_eMsg;

enum net_eEvent {
	net_eEvent__ = -1,
	net_eEvent_nodeUp = 0,
	net_eEvent_nodeDown = 0 + 1,
	net_eEvent_id = 0 + 2,
	net_eEvent_idAck = 0 + 3,
	net_eEvent_idAck2 = 0 + 4,
	net_eEvent_error = 0 + 5,
	net_eEvent_other = 0 + 6,
	net_eEvent_ = 0 + 7,
};
typedef enum net_eEvent net_eEvent;
typedef union {
 pwr_tBitMask m;
 pwr_32Bits (
 pwr_Bits( linkStates , 1),
 pwr_Bits( id , 1),
 pwr_Bits( messages , 1),
 pwr_Bits( tmon , 1),
 pwr_Bits( cacheTrim , 1),
 pwr_Bits( sub , 1),
 pwr_Bits( san , 1),
 pwr_Bits( fill0 , 1),

 pwr_Bits( fill1 , 8),,,,,,,,
 pwr_Bits( fill2 , 8),,,,,,,,
 pwr_Bits( fill3 , 8),,,,,,,
 ) b;

#define net_mLog__ 0
#define net_mLog_linkStates pwr_Bit(0)
#define net_mLog_id pwr_Bit(1)
#define net_mLog_messages pwr_Bit(2)
#define net_mLog_tmon pwr_Bit(3)
#define net_mLog_cacheTrim pwr_Bit(4)
#define net_mLog_sub pwr_Bit(5)
#define net_mLog_san pwr_Bit(6)
#define net_mLog_ (~net_mLog__)

#define net_mLog_all net_mLog_
} net_mLog;


struct net_sMessage {
	pwr_tBoolean xdr;
	pwr_tUInt32 msn;
	pwr_tNodeId nid;
};
typedef struct net_sMessage net_sMessage;

struct net_sError {
	net_sMessage hdr;
	qcom_sQid remqid;
	pwr_tStatus sts;
};
typedef struct net_sError net_sError;

struct net_sNode {
	qcom_sQid handler;
	pwr_tUInt32 netver;
	pwr_tObjid nod_oid;
	pwr_tObjid vol_oid;
};
typedef struct net_sNode net_sNode;

struct net_sId {
	net_sMessage hdr;
	net_sNode node;
};
typedef struct net_sId net_sId;

struct net_sIdAck2 {
	net_sMessage hdr;
};
typedef struct net_sIdAck2 net_sIdAck2;

struct net_sNodeUp {
	net_sMessage hdr;
	pwr_tNodeId nid;
};
typedef struct net_sNodeUp net_sNodeUp;

enum net_eState {
	net_eState__ = -1,
	net_eState_down = -1 + 1,
	net_eState_istrt = -1 + 2,
	net_eState_astrt = -1 + 3,
	net_eState_up = -1 + 4,
	net_eState_ = -1 + 5,
};
typedef enum net_eState net_eState;

struct net_sClassDef {
	pwr_tInt32 Editor;
	pwr_tInt32 Method;
	pwr_tUInt32 Flags;
	pwr_tUInt32 NumOfObjBodies;
	pwr_tInt32 PopEditor;
};
typedef struct net_sClassDef net_sClassDef;

struct net_sObjBodyDef {
	pwr_tStructName StructName;
	pwr_tUInt32 NumOfParams;
	pwr_tUInt32 Size;
	pwr_tUInt32 NextAix;
	pwr_tUInt32 Flags;
};
typedef struct net_sObjBodyDef net_sObjBodyDef;

struct net_sParInfo {
	pwr_tPgmName PgmName;
	pwr_eType Type;
	pwr_tUInt32 Offset;
	pwr_tUInt32 Size;
	pwr_tUInt32 Flags;
	pwr_tUInt32 Elements;
	pwr_tUInt32 ParamIndex;
};
typedef struct net_sParInfo net_sParInfo;

struct net_sParam {
	net_sParInfo Info;
	pwr_tTypeId TypeRef;
};
typedef struct net_sParam net_sParam;

struct net_sSubSpec {
	pwr_tSubid sid;
	pwr_tUInt32 dt;
	pwr_tBoolean sub_by_name;
	pwr_sAttrRef aref;
};
typedef struct net_sSubSpec net_sSubSpec;
#define net_cSubMaxAdd (net_cSizeLarge/sizeof(net_sSubSpec))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 count pwr_dPacked; /* # of entries */
 net_sSubSpec spec[1]; /* Specifications (dynamic) */
} net_sSubAdd;

bool_t
xdr_net_sSubAdd();

/* Remove subscription.  */

#define net_cSubMaxRemove (net_cSizeLarge/sizeof(pwr_tSubid))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 count pwr_dPacked; /* # of removals */
 pwr_tSubid sid[1] pwr_dPacked; /* Subscription to remove */
} net_sSubRemove;

bool_t
xdr_net_sSubRemove();

/* Subscription data transfer.  */

typedef struct {
 pwr_tSubid sid pwr_dPacked; /* Tag */
 pwr_tStatus sts pwr_dPacked; /* Status */
 pwr_tUInt32 size pwr_dPacked; /* Size of data */
 char data[1]; /* Dynamic */
} net_sSubData;
bool_t xdr_net_sSubData();

#define net_cSubMaxMessage 100

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header when used as message */
 pwr_tUInt32 count pwr_dPacked; /* # of subdata entries in msg */
 net_sSubData subdata[1]; /* Dynamic */
} net_sSubMessage;

bool_t xdr_net_sSubMessage();


struct net_sSanEntry {
	pwr_tObjid oid;
	pwr_tSubid sid;
};
typedef struct net_sSanEntry net_sSanEntry;
#define net_cSanMaxAdd (net_cSizeLarge/sizeof(net_sSanEntry))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tVolumeId vid pwr_dPacked;
 pwr_tUInt32 count pwr_dPacked; /* # of entries */
 net_sSanEntry sane[1] pwr_dPacked;
} net_sSanAdd;

bool_t xdr_net_sSanAdd();

#define net_cSanMaxRemove (net_cSizeLarge/sizeof(pwr_tSubid))

typedef struct net_sSanRemove {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tVolumeId vid pwr_dPacked;
 pwr_tUInt32 count pwr_dPacked; /* # of removals */
 pwr_tSubid sid[1] pwr_dPacked; /* Subscriptions to remove (dynamic) */
} net_sSanRemove;

bool_t xdr_net_sSanRemove();


struct net_sAlarm {
	pwr_tUInt32 a;
	pwr_tUInt32 b;
	pwr_tUInt32 maxa;
	pwr_tUInt32 maxb;
	pwr_tUInt32 idx;
};
typedef struct net_sAlarm net_sAlarm;

struct net_sSanData {
	net_sSanEntry sane;
	net_sAlarm al;
};
typedef struct net_sSanData net_sSanData;
#define net_cSanMaxUpdate (net_cSizeLarge/sizeof(net_sSanData))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header when used as message */
 pwr_tUInt32 count pwr_dPacked; /* # of SUBDATA entries in msg */
 net_sSanData data[1] pwr_dPacked; /* Dynamic */
} net_sSanUpdate;

bool_t xdr_net_sSanUpdate();
/*  Cache inquiry, fetch by name.  */

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tObjid poid pwr_dPacked; /* Parent of name */
 pwr_tBitMask trans pwr_dPacked; /* Translation mask.  */
 pwr_tUInt32 lcount pwr_dPacked; /* Number of left siblings wanted. */
 pwr_tUInt32 rcount pwr_dPacked; /* Number of lright siblings wanted. */
 pwr_tUInt32 len pwr_dPacked; /* name buffer length */
 char name[1]; /* name buffer */
} net_sNameToObject;

bool_t xdr_net_sNameToObject();

struct net_sOidToObject {
	net_sMessage hdr;
	pwr_tObjid oid;
	pwr_tBitMask trans;
	pwr_tUInt32 lcount;
	pwr_tUInt32 rcount;
};
typedef struct net_sOidToObject net_sOidToObject;
typedef union {
 pwr_tBitMask m;
 pwr_32Bits (
 pwr_Bits( isParent , 1),
 pwr_Bits( isAliasClient , 1),
 pwr_Bits( isAliasServer , 1),
 pwr_Bits( isMountClient , 1),
 pwr_Bits( inSibList , 1),
 pwr_Bits( hasSubClass , 1),
 pwr_Bits( fill0 , 2),,

 pwr_Bits( fill1 , 8),,,,,,,,
 pwr_Bits( fill2 , 8),,,,,,,,
 pwr_Bits( fill3 , 8),,,,,,,
 ) b;

#define net_mGo__ 0
#define net_mGo_isParent pwr_Bit(0)
#define net_mGo_isAliasClient pwr_Bit(1)
#define net_mGo_isAliasServer pwr_Bit(2)
#define net_mGo_isMountClient pwr_Bit(3)
#define net_mGo_inSibList pwr_Bit(4)
#define net_mGo_hasSubClass pwr_Bit(5)

#define net_mGo_isClient (net_mGo_isAliasClient|net_mGo_isMountClient)

#define net_mGo_ (~net_mGo__)
} net_mGo;

struct net_sOixLink {
	pwr_tObjectIx flink;
	pwr_tObjectIx blink;
};
typedef struct net_sOixLink net_sOixLink;

struct net_sGobject {
	pwr_tObjid oid;
	pwr_tClassId cid;
	cdh_sFamily f;
	net_sOixLink sib;
	pwr_tObjid soid;
	pwr_tUInt32 size;
	net_mGo flags;
};
typedef struct net_sGobject net_sGobject;
#define net_cObjectMaxCount (net_cSizeLarge/sizeof(net_sGobject))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tStatus sts pwr_dPacked; /* Status code */
 pwr_tObjid oid pwr_dPacked; /* Objid of referenced object */
 pwr_tUInt32 count pwr_dPacked; /* # of headers in response */
 net_sGobject g[1] pwr_dPacked; /* Array of object headers */
} net_sObjectR;

bool_t xdr_net_sObjectR();


struct net_sGetObjectInfo {
	net_sMessage hdr;
	pwr_sAttrRef aref;
};
typedef struct net_sGetObjectInfo net_sGetObjectInfo;
typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 sts pwr_dPacked; /* Status code */
 pwr_sAttrRef aref pwr_dPacked; /* Copy of requested info */
 pwr_tUInt32 size pwr_dPacked; /* Size of requested data, same as aref.size, in bytes.  */
 char info[1]; /* Data requested.  */
} net_sGetObjectInfoR;

bool_t xdr_net_sGetObjectInfoR();

/* Set object information.  */

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_sAttrRef aref pwr_dPacked; /* Data reference */
 pwr_tUInt32 size pwr_dPacked; /* Size of requested data, same as aref.size, in bytes.  */
 char info[1]; /* Data to write (size bytes) */
} net_sSetObjectInfo;

bool_t xdr_net_sSetObjectInfo();


struct net_sSetObjectInfoR {
	net_sMessage hdr;
	pwr_tUInt32 sts;
	pwr_sAttrRef aref;
};
typedef struct net_sSetObjectInfoR net_sSetObjectInfoR;

struct net_sSiblings {
	pwr_tObjectIx flink;
	pwr_tObjectIx newblink;
	pwr_tObjectIx blink;
	pwr_tObjectIx newflink;
};
typedef struct net_sSiblings net_sSiblings;

struct net_sParent {
	pwr_tObjid oid;
	pwr_tObjid soid;
};
typedef struct net_sParent net_sParent;

struct net_sNotify {
	net_sMessage hdr;
	pwr_tObjid oid;
};
typedef struct net_sNotify net_sNotify;

struct net_sCreateObject {
	net_sNotify notify;
	net_sParent par;
	net_sSiblings sib;
};
typedef struct net_sCreateObject net_sCreateObject;

struct net_sDeleteObject {
	net_sNotify notify;
	net_sParent par;
	net_sSiblings sib;
};
typedef struct net_sDeleteObject net_sDeleteObject;

struct net_sMoveObject {
	net_sNotify notify;
	net_sOixLink sib;
	net_sParent opar;
	net_sSiblings osib;
	net_sParent npar;
	net_sSiblings nsib;
};
typedef struct net_sMoveObject net_sMoveObject;

struct net_sRenameObject {
	net_sNotify notify;
	cdh_sFamily f;
};
typedef struct net_sRenameObject net_sRenameObject;

struct net_sTime {
	u_int tv_sec;
	u_int tv_nsec;
};
typedef struct net_sTime net_sTime;

struct net_sGvolume {
	pwr_tVolumeId vid;
	pwr_tObjid oid;
	cdh_sObjName name;
	pwr_tClassId cid;
	pwr_tNodeId nid;
	net_sTime time;
};
typedef struct net_sGvolume net_sGvolume;

struct net_sGvolume7 {
	pwr_tVolumeId vid;
	pwr_tObjid oid;
	cdh_sObjName name;
	pwr_tClassId cid;
	pwr_tNodeId nid;
};
typedef struct net_sGvolume7 net_sGvolume7;

#define net_cVolumeMaxCount (net_cSizeLarge/sizeof(net_sGvolume))

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 ctx pwr_dPacked;
 pwr_tUInt32 count pwr_dPacked; /* # of headers  */
 net_sGvolume g[1] pwr_dPacked; /* Array of volume headers */
} net_sVolumes;

bool_t xdr_net_sVolumes();

typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 ctx pwr_dPacked;
 pwr_tUInt32 count pwr_dPacked; /* # of headers  */
 net_sGvolume7 g[1] pwr_dPacked; /* Array of volume headers */
} net_sVolumes7;

bool_t xdr_net_sVolumes7();


struct net_sMount {
	pwr_tVolumeId vid;
};
typedef struct net_sMount net_sMount;
typedef struct {
 net_sMessage hdr pwr_dPacked; /* Header */
 pwr_tUInt32 ctx pwr_dPacked;
 pwr_tUInt32 count pwr_dPacked; /* # of headers  */
 net_sMount mount[1] pwr_dPacked;/* Array of mount requests */
} net_sVolumesR;

bool_t xdr_net_sVolumesR();


struct net_sGattribute {
	net_sGobject ao;
	net_sParam ab;
};
typedef struct net_sGattribute net_sGattribute;

struct net_sGclass {
	net_sTime time;
	pwr_tBitMask dbsFlags;
	net_sGobject co;
	net_sClassDef cb;
	net_sGobject bo;
	net_sObjBodyDef bb;
	pwr_tUInt32 size;
	pwr_tUInt32 acount;
};
typedef struct net_sGclass net_sGclass;

struct net_sGetGclass {
	net_sMessage hdr;
	pwr_tUInt32 ver;
	pwr_tClassId cid;
	pwr_tUInt32 aidx;
};
typedef struct net_sGetGclass net_sGetGclass;


typedef struct {
 net_sMessage hdr;/**< Header */
 pwr_tUInt32 ver;/**< see net_sMessage for comment */
 pwr_tStatus sts;/**< Status */

 /* The data below is only valid if ODD(sts) */

 pwr_tObjName vname; /**< Volume name, needed if volume must be created */
 pwr_tUInt32 acntmsg; /**< Number of attributes in this message. */
 pwr_tUInt32 saidx; /**< Starting attribute index */
 pwr_tUInt32 naidx; /**< Index for next attribute which didn't fit 
                                    in this message or ULONG_MAX if all included */
 net_sGclass gclass;
 net_sGattribute attr[1]; /**< Array of attributes */
} net_sGetGclassR;

bool_t xdr_net_sGetGclassR(XDR *xdrs, net_sGetGclassR *objp);


struct net_sCattribute {
	pwr_tAix aix;
	pwr_mAdef flags;
	pwr_eType type;
	pwr_tUInt32 offs;
	pwr_tUInt32 size;
	pwr_tUInt32 elem;
	pwr_tUInt32 moffset;
};
typedef struct net_sCattribute net_sCattribute;

struct net_sCclass {
	pwr_tClassId cid;
	net_sTime time;
	pwr_tUInt32 size;
	pwr_tUInt32 acount;
};
typedef struct net_sCclass net_sCclass;

struct net_sGetCclass {
	net_sMessage hdr;
	pwr_tUInt32 ver;
	pwr_tClassId cid;
	net_sTime time;
	pwr_tUInt32 aidx;
};
typedef struct net_sGetCclass net_sGetCclass;

typedef struct {
 net_sMessage hdr; /**< Header */
 pwr_tUInt32 ver; /**< see net_sMessage for comment */
 pwr_tStatus sts; /**< Status */
 pwr_tBoolean equal; /**< The remote class is equal to the native */

 /* 
   * The data below is only valid if ODD(sts) and !equal 
   */

 pwr_tUInt32 acntmsg; /**< Number of attributes in this message. */
 pwr_tUInt32 saidx; /**< Starting attribute index */
 pwr_tUInt32 naidx; /**< Index for next attribute which didn't fit 
                                    in this message or ULONG_MAX if all included */
 net_sCclass cclass;
 net_sCattribute attr[1]; /**< Array of attributes */
} net_sGetCclassR;


bool_t xdr_net_sGetCclassR(XDR *xdrs, net_sGetCclassR *objp);


struct net_sFileList {
	net_sMessage hdr;
	char dir[256];
	char pattern[40];
};
typedef struct net_sFileList net_sFileList;


typedef struct {
 net_sMessage hdr; /**< Header */
 pwr_tStatus sts; /**< Status */
 pwr_tUInt32 filecnt; /**< Number of files found. */
 char files[1]; /**< List of files */
} net_sFileListR;

bool_t xdr_net_sFileListR(XDR *xdrs, net_sFileListR *objp);


struct net_sGetCircBuffer {
	net_sMessage hdr;
	pwr_sAttrRef circ_aref;
	pwr_tUInt32 resolution;
	pwr_tUInt32 samples;
	pwr_tUInt32 bufsize;
};
typedef struct net_sGetCircBuffer net_sGetCircBuffer;


typedef struct {
 net_sMessage hdr; /**< Header */
 pwr_tStatus sts; /**< Status */
 pwr_sAttrRef circ_aref; /**< CircBuffer attribute reference. */
 pwr_tUInt32 first_idx; /**< First index in buffer. */
 pwr_tUInt32 last_idx; /**< Last index in buffer. */
 pwr_tUInt32 offset; /**< Offset for next update. */
 pwr_tUInt32 size; /**< Returned number of samples. */
 pwr_tUInt32 bufsize; /**< Size data in bytes. */
 char buf[1]; /**< Data */
} net_sGetCircBufferR;

bool_t xdr_net_sGetCircBufferR(XDR *xdrs, net_sGetCircBufferR *objp);


struct net_sUpdateCircBuffer {
	net_sMessage hdr;
	pwr_tUInt32 info_size;
	pwr_sAttrRef circ_aref[10];
	pwr_tUInt32 resolution[10];
	pwr_tUInt32 samples[10];
	pwr_tUInt32 last_idx[10];
	pwr_tUInt32 offset[10];
	pwr_tUInt32 bufsize[10];
};
typedef struct net_sUpdateCircBuffer net_sUpdateCircBuffer;


typedef struct {
 net_sMessage hdr; /**< Header */
 pwr_tStatus sts; /**< Status */
 pwr_tUInt32 info_size;
 pwr_sAttrRef circ_aref[10]; /**< CircBuffer attribute reference. */
 pwr_tUInt32 first_idx[10]; /**< First index in buffer. */
 pwr_tUInt32 last_idx[10]; /**< Last index in buffer. */
 pwr_tUInt32 offset[10]; /**< Offset for next update. */
 pwr_tUInt32 size[10]; /**< Returned number of samples. */
 pwr_tUInt32 bufsize[10]; /**< Size data for each item in bytes. */
 pwr_tUInt32 bsize; /**< Total size data in bytes. */
 char buf[1]; /**< Data */
} net_sUpdateCircBufferR;

bool_t xdr_net_sUpdateCircBufferR(XDR *xdrs, net_sUpdateCircBufferR *objp);

/*  Max # of gohs in a cache_fetch_response. The message will not be
    bigger than cvol_cMaxSize bytes.  */

/* Callable functions.  */

void *
net_Alloc (
 pwr_tStatus *sts,
 qcom_sPut *put,
 int size,
 net_eMsg subtype
);

pwr_tBoolean
net_Free (
 pwr_tStatus *sts,
 void *mp
);

pwr_tBoolean
net_Send (
 pwr_tStatus *sts,
 qcom_sQid *tgt,
 qcom_sPut *put
);

pwr_tBoolean
net_Reply (
 pwr_tStatus *sts,
 qcom_sGet *get,
 qcom_sPut *put,
 pwr_tSid sid
);

pwr_tBoolean
net_Put (
 pwr_tStatus *sts,
 qcom_sQid *tgt,
 void *mp,
 net_eMsg type,
 unsigned int id,
 int size,
 pwr_tSid sid
);

void *
net_Receive (
 pwr_tStatus *sts,
 qcom_sGet *get,
 int tmo
);

void *
net_Request (
 pwr_tStatus *sts,
 qcom_sQid *tgt,
 qcom_sPut *put,
 qcom_sGet *get,
 net_eMsg gtype,
 pwr_tBitMask flags,
 pwr_tSid sid
);

pwr_tBoolean
net_Connect (
 pwr_tStatus *sts,
 qcom_sAid *aid,
 qcom_sQid *qid,
 qcom_sQattr *attr,
 const char *name
);

static const net_sTime net_cNTime = {0, 0};

pwr_tTime net_NetTimeToTime( const net_sTime *nt);
net_sTime net_TimeToNetTime( const pwr_tTime *t);
pwr_tDeltaTime net_NetTimeToDeltaTime( const net_sTime *nt);
net_sTime net_DeltaTimeToNetTime( const pwr_tDeltaTime *t);
net_sTime net_DeltaTimeToNetTime( const pwr_tDeltaTime *t);
int net_GetTime( net_sTime *nt);
int net_StringToAddr( char *str, struct in_addr *naddr);

#endif

#if defined __cplusplus
}
#endif

/* the xdr functions */

#if defined(__STDC__) || defined(__cplusplus)
extern  bool_t xdr_net_eMsg (XDR *, net_eMsg*);
extern  bool_t xdr_net_eEvent (XDR *, net_eEvent*);
extern  bool_t xdr_net_sMessage (XDR *, net_sMessage*);
extern  bool_t xdr_net_sError (XDR *, net_sError*);
extern  bool_t xdr_net_sNode (XDR *, net_sNode*);
extern  bool_t xdr_net_sId (XDR *, net_sId*);
extern  bool_t xdr_net_sIdAck2 (XDR *, net_sIdAck2*);
extern  bool_t xdr_net_sNodeUp (XDR *, net_sNodeUp*);
extern  bool_t xdr_net_eState (XDR *, net_eState*);
extern  bool_t xdr_net_sClassDef (XDR *, net_sClassDef*);
extern  bool_t xdr_net_sObjBodyDef (XDR *, net_sObjBodyDef*);
extern  bool_t xdr_net_sParInfo (XDR *, net_sParInfo*);
extern  bool_t xdr_net_sParam (XDR *, net_sParam*);
extern  bool_t xdr_net_sSubSpec (XDR *, net_sSubSpec*);
extern  bool_t xdr_net_sSanEntry (XDR *, net_sSanEntry*);
extern  bool_t xdr_net_sAlarm (XDR *, net_sAlarm*);
extern  bool_t xdr_net_sSanData (XDR *, net_sSanData*);
extern  bool_t xdr_net_sOidToObject (XDR *, net_sOidToObject*);
extern  bool_t xdr_net_sOixLink (XDR *, net_sOixLink*);
extern  bool_t xdr_net_sGobject (XDR *, net_sGobject*);
extern  bool_t xdr_net_sGetObjectInfo (XDR *, net_sGetObjectInfo*);
extern  bool_t xdr_net_sSetObjectInfoR (XDR *, net_sSetObjectInfoR*);
extern  bool_t xdr_net_sSiblings (XDR *, net_sSiblings*);
extern  bool_t xdr_net_sParent (XDR *, net_sParent*);
extern  bool_t xdr_net_sNotify (XDR *, net_sNotify*);
extern  bool_t xdr_net_sCreateObject (XDR *, net_sCreateObject*);
extern  bool_t xdr_net_sDeleteObject (XDR *, net_sDeleteObject*);
extern  bool_t xdr_net_sMoveObject (XDR *, net_sMoveObject*);
extern  bool_t xdr_net_sRenameObject (XDR *, net_sRenameObject*);
extern  bool_t xdr_net_sTime (XDR *, net_sTime*);
extern  bool_t xdr_net_sGvolume (XDR *, net_sGvolume*);
extern  bool_t xdr_net_sGvolume7 (XDR *, net_sGvolume7*);
extern  bool_t xdr_net_sMount (XDR *, net_sMount*);
extern  bool_t xdr_net_sGattribute (XDR *, net_sGattribute*);
extern  bool_t xdr_net_sGclass (XDR *, net_sGclass*);
extern  bool_t xdr_net_sGetGclass (XDR *, net_sGetGclass*);
extern  bool_t xdr_net_sCattribute (XDR *, net_sCattribute*);
extern  bool_t xdr_net_sCclass (XDR *, net_sCclass*);
extern  bool_t xdr_net_sGetCclass (XDR *, net_sGetCclass*);
extern  bool_t xdr_net_sFileList (XDR *, net_sFileList*);
extern  bool_t xdr_net_sGetCircBuffer (XDR *, net_sGetCircBuffer*);
extern  bool_t xdr_net_sUpdateCircBuffer (XDR *, net_sUpdateCircBuffer*);

#else /* K&R C */
extern bool_t xdr_net_eMsg ();
extern bool_t xdr_net_eEvent ();
extern bool_t xdr_net_sMessage ();
extern bool_t xdr_net_sError ();
extern bool_t xdr_net_sNode ();
extern bool_t xdr_net_sId ();
extern bool_t xdr_net_sIdAck2 ();
extern bool_t xdr_net_sNodeUp ();
extern bool_t xdr_net_eState ();
extern bool_t xdr_net_sClassDef ();
extern bool_t xdr_net_sObjBodyDef ();
extern bool_t xdr_net_sParInfo ();
extern bool_t xdr_net_sParam ();
extern bool_t xdr_net_sSubSpec ();
extern bool_t xdr_net_sSanEntry ();
extern bool_t xdr_net_sAlarm ();
extern bool_t xdr_net_sSanData ();
extern bool_t xdr_net_sOidToObject ();
extern bool_t xdr_net_sOixLink ();
extern bool_t xdr_net_sGobject ();
extern bool_t xdr_net_sGetObjectInfo ();
extern bool_t xdr_net_sSetObjectInfoR ();
extern bool_t xdr_net_sSiblings ();
extern bool_t xdr_net_sParent ();
extern bool_t xdr_net_sNotify ();
extern bool_t xdr_net_sCreateObject ();
extern bool_t xdr_net_sDeleteObject ();
extern bool_t xdr_net_sMoveObject ();
extern bool_t xdr_net_sRenameObject ();
extern bool_t xdr_net_sTime ();
extern bool_t xdr_net_sGvolume ();
extern bool_t xdr_net_sGvolume7 ();
extern bool_t xdr_net_sMount ();
extern bool_t xdr_net_sGattribute ();
extern bool_t xdr_net_sGclass ();
extern bool_t xdr_net_sGetGclass ();
extern bool_t xdr_net_sCattribute ();
extern bool_t xdr_net_sCclass ();
extern bool_t xdr_net_sGetCclass ();
extern bool_t xdr_net_sFileList ();
extern bool_t xdr_net_sGetCircBuffer ();
extern bool_t xdr_net_sUpdateCircBuffer ();

#endif /* K&R C */

#ifdef __cplusplus
}
#endif

#endif /* !_RT_NET_H_RPCGEN */
